import{_ as s,o as a,c as n,a as e}from"./app-8ca7f52c.js";const p={},t=e(`<h1 id="es-概念及原理" tabindex="-1"><a class="header-anchor" href="#es-概念及原理" aria-hidden="true">#</a> ES 概念及原理</h1><h2 id="架构图" tabindex="-1"><a class="header-anchor" href="#架构图" aria-hidden="true">#</a> 架构图</h2><p><img src="https://assets.moweilong.com/img/20231027174636.png" alt="ES 架构图"></p><h2 id="集群" tabindex="-1"><a class="header-anchor" href="#集群" aria-hidden="true">#</a> 集群</h2><h3 id="cluster" tabindex="-1"><a class="header-anchor" href="#cluster" aria-hidden="true">#</a> Cluster</h3><p>互联网应用中，随着站点对硬件性能、响应速度、服务稳定性、数据可靠性等要求越来越高，单台服务器开始无法满足负载均衡及高可用的需求，集群因此应运而生。</p><p>ES 集群是由一个或多个节点组成，对外表现为一个整体，提供索引和搜索功能，在所有节点，一个集群有一个唯一的名称默认为 elasticsearch，当节点被设置为相同的集群名称中，就会自动加入集群，当需要有多个集群的时候，需要确保每个集群的名称不能重复，否则节点可能加入错误的集群，一个节点只能添加一个集群。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p><h3 id="node" tabindex="-1"><a class="header-anchor" href="#node" aria-hidden="true">#</a> Node</h3><p>节点是组成 ES 集群的基本单位，一个节点就是一个 ES 服务的实例，也可以理解为一个 es 的进程，每个物理机器上可以有多个节点，使用不同的端口和节点名称。每个节点可以配置不同的角色。</p><p>当一个节点被选举成为 主节点 时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。</p><h3 id="roles" tabindex="-1"><a class="header-anchor" href="#roles" aria-hidden="true">#</a> Roles</h3><p>在高可用系统架构中，节点角色发挥着至关重要的作用，如果前期没有对业务系统和技术架构做足准备，没有充分考虑后期的扩展问题，是比会为将来的性能优化留下潜在问题。</p><p>常见的角色：</p><ul><li>主节点（active master）：活跃的主节点，一个集群中的只能有一个，主要对集群的管理。</li><li>候选节点（master eligible）：当主节点发生故障时，能够参与选举，是主节点的替代节点，直接在配置文件中配置 node.roles 为 master。</li><li>数据节点（data node）：数据节点保存包含已编入索引的文档的分片，数据节点处理数据相关操作，如 CURD、搜索和聚合。这些操作是 I/O 密集型、内存密集型和 CPU 密集型的。监控这些资源并在它们过载的时候添加更所的数据节点非常重要。</li><li>预处理节点（ingset node）：预处理节点有点类似于 logstash 的消息管道，所以也叫 ingset pippline，常用于一些数据写入之前的预处理操作，如垃圾数据的过滤等。</li></ul><p>默认情况下，node.roles 是没有配置，为注释状态，那么当前节点具备所有角色状态。8.x 版本配置文件中修改： node.roles:[master, data, xxx]，角色配置项参考官网 节点角色。</p><h3 id="shard" tabindex="-1"><a class="header-anchor" href="#shard" aria-hidden="true">#</a> Shard</h3><p>分片就是把一份数据分散的存储到不同的节点上，分为 主分片(Primary shard) 和 副本分片(Replica shard)：</p><ul><li>主分片（Primary shard）：用于解决数据水平扩展的问题，通过主分片，可以将数据分布到集群内的所有节点之上，将一份索引数据划分为多小份的能力，允许水平分割和扩展容量。多个分片可以响应请求，提高性能和吞吐量。一个节点(Node)一般会管理多个分片，分片有两种，主分片和副本分片。</li><li>副本分片（Replica shard）：副本分片只是一个主分片的拷贝。 副本分片作为硬件故障时保护数据不丢失的冗余备份，从而提高整个集群的容错性，并为搜索和返回文档等读操作提供服务，且需要注意的是副本分片不能与主分片在同一个节点。。一般来说，Elasticsearch 会尽量把一个索引的不同分片存储在不同的主机上，分片的副本也尽可能存在不同的主机上，这样可以提高容错率，从而提高高可用性。</li></ul><p>一个索引（Index）数据在物理上被分布在一个或多个主分片中，每个主分片只存放部分数据，每个主分片可以有多个副本。</p><ul><li>主分片的作用是对索引的扩容，使一个索引的容量可以突破单机的限制。</li><li>副本分片是对数据的保护，每个主分片对应一个或多个副本分片，当主分片所在节点宕机时，副本分片会被提升为对应的主分片使用。</li><li>一个主分片和它的副本分片，不会分配到同一个节点上。</li><li>一个分片就是一个 Lucene 实例，并且它本身就是一个完整的搜索引擎。应用程序不会和它直接通信，ES 会自动管理集群中的所有分片，当发生故障的时候会把分片移动到不同的节点或者添加新节点。</li><li>在 7.0 之前默认五个主分片，每个主分片一个副本；在 7.0 之后默认一个主分片。</li><li>当索引创建完成的时候，主分片的数量就固定了，如果要修改需要重建索引，代价很高，如果要修改则需 Reindex，但是复制分片的数量可以随时调整。</li></ul><h3 id="集群健康" tabindex="-1"><a class="header-anchor" href="#集群健康" aria-hidden="true">#</a> 集群健康</h3><p>Elasticsearch 的集群监控信息中包含了许多的统计数据，其中最为重要的一项就是 集群健康 ， 它在 status 字段中展示为 green 、yellow 或者 red 。status 字段指示着当前集群在总体上是否工作正常。它的三种颜色含义如下：</p><ul><li>green：所有的主分片和副本分片都正常运行。</li><li>yellow：所有的主分片都正常运行，但不是所有的副本分片都正常运行。</li><li>red：有主分片没能正常运行。</li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>GET /_cluster/health
<span class="token punctuation">{</span>
   <span class="token property">&quot;cluster_name&quot;</span><span class="token operator">:</span>          <span class="token string">&quot;elasticsearch&quot;</span><span class="token punctuation">,</span>
   <span class="token property">&quot;status&quot;</span><span class="token operator">:</span>                <span class="token string">&quot;green&quot;</span><span class="token punctuation">,</span>
   <span class="token property">&quot;timed_out&quot;</span><span class="token operator">:</span>             <span class="token boolean">false</span><span class="token punctuation">,</span>
   <span class="token property">&quot;number_of_nodes&quot;</span><span class="token operator">:</span>       <span class="token number">1</span><span class="token punctuation">,</span>
   <span class="token property">&quot;number_of_data_nodes&quot;</span><span class="token operator">:</span>  <span class="token number">1</span><span class="token punctuation">,</span>
   <span class="token property">&quot;active_primary_shards&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
   <span class="token property">&quot;active_shards&quot;</span><span class="token operator">:</span>         <span class="token number">0</span><span class="token punctuation">,</span>
   <span class="token property">&quot;relocating_shards&quot;</span><span class="token operator">:</span>     <span class="token number">0</span><span class="token punctuation">,</span>
   <span class="token property">&quot;initializing_shards&quot;</span><span class="token operator">:</span>   <span class="token number">0</span><span class="token punctuation">,</span>
   <span class="token property">&quot;unassigned_shards&quot;</span><span class="token operator">:</span>     <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="空节点" tabindex="-1"><a class="header-anchor" href="#空节点" aria-hidden="true">#</a> 空节点</h3><p>如果我们启动了一个单独的节点，里面不包含任何的数据和索引，那我们的集群看起来如下图：</p><p><img src="https://assets.moweilong.com/img/20231027174705.png" alt="ES master"></p><p>当一个节点被选举成为 主节点 时，它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。当一个节点被选举成为 主节点 时，它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。任何节点都可以成为主节点。</p><h3 id="单节点" tabindex="-1"><a class="header-anchor" href="#单节点" aria-hidden="true">#</a> 单节点</h3><p>对索引还不了解的话可以先看看下面的索引部分操作。</p><p>让我们在包含一个空节点的集群内创建名为 blogs 的索引。 7.0 之后索引在默认情况下会被分配 1 个主分片和 1 个副分片， 但是为了演示目的，我们将分配 3 个主分片和一份副本（每个主分片拥有一个副本分片）：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>PUT /blogs
<span class="token punctuation">{</span>
   <span class="token property">&quot;settings&quot;</span> <span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">&quot;number_of_shards&quot;</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
      <span class="token property">&quot;number_of_replicas&quot;</span> <span class="token operator">:</span> <span class="token number">1</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://assets.moweilong.com/img/20231027174713.png" alt="ES 单节点"></p><p>查看集群健康：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>GET /_cluster/health
<span class="token punctuation">{</span>
  <span class="token property">&quot;cluster_name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;elasticsearch&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;status&quot;</span><span class="token operator">:</span> <span class="token string">&quot;yellow&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;timed_out&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token property">&quot;number_of_nodes&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token property">&quot;number_of_data_nodes&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token property">&quot;active_primary_shards&quot;</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token property">&quot;active_shards&quot;</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token property">&quot;relocating_shards&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;initializing_shards&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;unassigned_shards&quot;</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token property">&quot;delayed_unassigned_shards&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;number_of_pending_tasks&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;number_of_in_flight_fetch&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;task_max_waiting_in_queue_millis&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;active_shards_percent_as_number&quot;</span><span class="token operator">:</span> <span class="token number">50</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>集群的健康状况为 yellow 则表示全部 主分片都正常运行（集群可以正常服务所有请求），但是 副本分片没有全部处在正常状态。 实际上，所有 3 个副本分片都是 unassigned —— 它们都没有被分配到任何节点。 在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。</p><p>当前我们的集群是正常运行的，但是在硬件故障时有丢失数据的风险。</p><h3 id="追加节点" tabindex="-1"><a class="header-anchor" href="#追加节点" aria-hidden="true">#</a> 追加节点</h3><p>当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。 幸运的是，我们只需再启动一个节点即可防止数据丢失。</p><p>如果启动了第二个节点，我们的集群将会如下所示：</p><p><img src="https://assets.moweilong.com/img/20231027174724.png" alt="ES 追加节点"></p><p>当第二个节点加入到集群后，3 个 副本分片 将会分配到这个节点上——每个主分片对应一个副本分片。 这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。</p><p>所有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档。</p><p>cluster-health 现在展示的状态为 green ，这表示所有 6 个分片（包括 3 个主分片和 3 个副本分片）都在正常运行。</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>GET /_cluster/health
<span class="token punctuation">{</span>
  <span class="token property">&quot;cluster_name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;elasticsearch&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;status&quot;</span><span class="token operator">:</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;timed_out&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token property">&quot;number_of_nodes&quot;</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token property">&quot;number_of_data_nodes&quot;</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token property">&quot;active_primary_shards&quot;</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token property">&quot;active_shards&quot;</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>
  <span class="token property">&quot;relocating_shards&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;initializing_shards&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;unassigned_shards&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;delayed_unassigned_shards&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;number_of_pending_tasks&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;number_of_in_flight_fetch&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;task_max_waiting_in_queue_millis&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;active_shards_percent_as_number&quot;</span><span class="token operator">:</span> <span class="token number">100</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="水平扩容" tabindex="-1"><a class="header-anchor" href="#水平扩容" aria-hidden="true">#</a> 水平扩容</h3><p>当启动了第三个节点，我们的集群将会看起来如下所示：</p><p><img src="https://assets.moweilong.com/img/20231027174732.png" alt="ES 水平扩容之扩容节点"></p><p>Node 1 和 Node 2 上各有一个分片被迁移到了新的 Node 3 节点，现在每个节点上都拥有 2 个分片，而不是之前的 3 个。 这表示每个节点的硬件资源（CPU, RAM, I/O）将被更少的分片所共享，每个分片的性能将会得到提升。</p><p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有 6 个分片（3 个主分片和 3 个副本分片）的索引可以最大扩容到 6 个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。</p><p>但是如果我们想要扩容超过 6 个节点怎么办呢？</p><p>主分片的数目在索引创建时就已经确定了下来。实际上，这个数目定义了这个索引能够 存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作（搜索和返回数据）可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。</p><p>在运行中的集群上是可以动态调整副本分片数目的，我们可以按需伸缩集群。让我们把副本数从默认的 1 增加到 2 ：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>PUT /blogs/_settings
<span class="token punctuation">{</span>
   <span class="token property">&quot;number_of_replicas&quot;</span> <span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如下图所示， blogs 索引现在拥有 9 个分片：3 个主分片和 6 个副本分片。 这意味着我们可以将集群扩容到 9 个节点，每个节点上一个分片。相比原来 3 个节点时，集群搜索性能可以提升 3 倍。</p><p><a href=""></a></p><p><img src="https://assets.moweilong.com/img/20231027174741.png" alt="ES 水平扩容之扩容副本分片"></p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>当然，如果只是在相同节点数目的集群上增加更多的副本分片并不能提高性能，因为每个分片从节点上获得的资源会变少。 你需要增加更多的硬件资源来提升吞吐量。</p><p>但是更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去 2 个节点的情况下不丢失任何数据。</p></div><h3 id="应对故障" tabindex="-1"><a class="header-anchor" href="#应对故障" aria-hidden="true">#</a> 应对故障</h3><p>我们之前说过 Elasticsearch 可以应对节点故障，接下来让我们尝试下这个功能。 如果我们关闭第一个节点，这时集群的状态如下：</p><p><img src="https://assets.moweilong.com/img/20231027174845.png" alt="ES 应对故障"></p><p>我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： Node 2 。</p><p>在我们关闭 Node 1 的同时也失去了主分片 1 和 2 ，并且在缺失主分片的时候索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 red ：不是所有主分片都在正常工作。</p><p>幸运的是，在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片， 此时集群的状态将会为 yellow 。 这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。</p><p>为什么我们集群状态是 yellow 而不是 green 呢？ 虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应 2 份副本分片，而此时只存在一份副本分片。 所以集群不能为 green 的状态，不过我们不必过于担心：如果我们同样关闭了 Node 2 ，我们的程序 依然 可以保持在不丢任何数据的情况下运行，因为 Node 3 为每一个分片都保留着一份副本。</p><p>如果我们重新启动 Node 1 ，集群可以将缺失的副本分片再次进行分配，那么集群的状态也将如 <code>水平扩容</code> 的第二张图所示。 如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。</p><h2 id="索引数据" tabindex="-1"><a class="header-anchor" href="#索引数据" aria-hidden="true">#</a> 索引数据</h2><p>Elasticsearch 使用 JSON 作为文档的序列化格式，分布式的 文档 存储。它能以实时的方式存储和检索复杂的数据结构 —​ 序列化成为 JSON 文档 。 换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。</p><p>在 Elasticsearch 中，每个字段的所有数据都是默认被索引的。 即每个字段都有为了快速检索设置的专用 倒排索引。而且，不像其他多数的数据库，它能在同一个查询中使用所有这些倒排索引，并以惊人的速度返回结果。</p><p>为什么选择 JSON 格式？ 我们经常会遇到下面这种情况：</p><p>现实中一个人可能有一个家庭电话号码，而另一个人只有一个手机号码，再一个人可能两者兼有。 一个人可能有三个电子邮件地址，而另一个人却一个都没有。一位西班牙人可能有两个姓，而讲英语的人可能只有一个姓。</p><p>面向对象编程语言中的对象可以帮我们表示和处理这种复杂的数据结构的实体对象，但是当我们需要存储这些实体对象时问题来了，传统上，我们以行和列的形式存储数据到关系型数据库中，相当于使用电子表格。 正因为我们使用了这种不灵活的存储媒介导致所有我们使用对象的灵活性都丢失了。</p><p>而 JSON 就是一种以人可读的文本表示对象的方法，它已经变成 NoSQL 世界交换数据的事实标准。当一个对象被序列化成为 JSON，它被称为一个 JSON 文档 。JSON 序列化被大多数编程语言所支持，并且已经成为 nosql 领域的标准格式，简单、简洁、易于阅读。</p><p>为了方便理解下面的数据结构，我们把 Elasticsearch 与关系型数据库 MySQL 做下简单类比：</p><table><thead><tr><th>Elasticsearch 8.x</th><th>MySQL</th></tr></thead><tbody><tr><td>Index（索引）</td><td>Table（数据表）</td></tr><tr><td>Type（类型）废弃</td><td></td></tr><tr><td>Dcoument（文档）</td><td>Row（行）</td></tr><tr><td>Mapping（映射）</td><td>Schema</td></tr><tr><td>Fields（字段）</td><td>Column（列）</td></tr></tbody></table><div class="hint-container tip"><p class="hint-container-title">提示</p><p>ES7.X 之后不推荐使用 type 类型，8.0 之后不能使用 type。</p></div><p>Segment：段，分片的 Lucene 由多个子索引（Lucene.index）组成，这些子索引就是段。每个段都包含索引文件和数据文件</p><h3 id="index" tabindex="-1"><a class="header-anchor" href="#index" aria-hidden="true">#</a> Index</h3><p>ES 中的索引有三种概念：</p><ul><li>表示源文件数据：当做数据的载体，即类比为数据表，通常称作 index。例如：通常说及群众有 product 索引，即表述在 ES 的服务中存储了 product 这样一张“表”。</li><li>表示索引文件：以加速查询检索为目的而设计和创建的数据文件，通常承载与某些特定的数据结构，如哈希、FST 等。例如：通常所说的正排索引和倒排索引（也叫正向索引和反向索引）。就是当前这个表述，索引文件和源数据是完全独立的，索引文件存在的目的仅仅是为了加快数据的检索，不会对源数据造成任何影响。</li><li>表示创建数据的动作：通常说创建或添加一条数据，在 ES 的表述为索引的一条数据或所以一条文档，或者一个 doc 进去，此时索引一条文档的含义为向索引中添加数据。</li></ul><h3 id="type-废弃" tabindex="-1"><a class="header-anchor" href="#type-废弃" aria-hidden="true">#</a> Type 废弃</h3><p>ES 7.x 之后不推荐使用 type 类型，8.0 之后不能使用 type。</p><p>为什么删除 type?</p><ul><li>逻辑不合理：然而这是错误的类比，官方后来也意识到了这是个错误。在 SQL 数据库中，表是相互独立的。一个表中的列与另一个表中的同名列无关。对于映射类型中的字段，情况并非如此。</li><li>数据结构混乱：在 Elasticsearch 索引中，不同映射类型中具有相同名称的字段在内部由相同的 Lucene 字段支持。</li><li>影响性能：最重要的是，在同一索引中存储具有很少或没有共同字段的不同实体会导致数据稀疏并干扰 Lucene 有效压缩文档的能力。</li></ul><p>基于以上原因，官方决定从 Elasticsearch 中删除映射类型的概念。</p><h3 id="document" tabindex="-1"><a class="header-anchor" href="#document" aria-hidden="true">#</a> Document</h3><p>文档是存储在 ES 中的一个 JSON 格式的字符串，它就像在关系数据库中表的一行，每个存储在索引中的一个文档都有一个类型和一个 ID，每个文档搜狐一个 JSON 对象，类似于数据库中的行。</p><h3 id="fields" tabindex="-1"><a class="header-anchor" href="#fields" aria-hidden="true">#</a> Fields</h3><p>文档中包含零个或多个字段，获取文档时可以指定字段返回。</p><h3 id="text" tabindex="-1"><a class="header-anchor" href="#text" aria-hidden="true">#</a> Text</h3><p>文本是一段普通的非结构化文字，通常文本会被拆成一个个的索引词，存储在 elasticsearch 的索引库中，为了让文本能够进行搜索，文本字段需要事先进行分析，当对文本中的关键词进行查询的时候，搜索引擎应该根据搜索条件搜索出原文件。</p><h3 id="term" tabindex="-1"><a class="header-anchor" href="#term" aria-hidden="true">#</a> Term</h3><p>在 ES 中索引词（term）是一个能够被索引的精确值，索引的最小单位，是经过分词处理后的字符串。</p><ul><li>如果是英文，忽略大小写，保存为小写格式，忽略一些无效词（比如 the）；</li><li>如果是中文，忽略一些无效词（比如“的”）</li></ul><h3 id="analyze" tabindex="-1"><a class="header-anchor" href="#analyze" aria-hidden="true">#</a> Analyze</h3><p>分析是将文本转换为索引词的过程，分析的结果依赖于分词器。在文档被加入索引之前，ES 让每个被分析字段经过一系列的处理步骤。</p><ul><li>字符过滤：使用字符过滤器转变字符。</li><li>文本切分为分词：将文本切分为单个或多个分词。</li><li>分词过滤：使用分词过滤器转变每个分词。</li><li>分词索引：将这些分词存储到索引中。</li></ul><h3 id="mapping" tabindex="-1"><a class="header-anchor" href="#mapping" aria-hidden="true">#</a> Mapping</h3><p>映射就像关系数据库中的表结构，每一个索引都有一个映射，它定义了索引中的每一个字段类型以及一个索引范围内的设置。</p><p>ES 中的 mapping 有点类似与关系数据库中 表结构 的概念，在 MySQL 中，表结构里包含了字段名称，字段的类型还有索引信息等。在 Mapping 里也包含了一些属性，比如字段名称、类型、字段使用的分词器、是否评分、是否创建索引等属性，并且在 ES 中一个字段可以有对个类型。</p><p>在我们创建索引的时候并不需要设置 mapping，是因为 ES 的映射有自己的默认的映射类型，参考下图：</p><p><img src="https://assets.moweilong.com/img/20231027174853.png" alt="ES 映射类型"></p><h3 id="routing" tabindex="-1"><a class="header-anchor" href="#routing" aria-hidden="true">#</a> Routing</h3><p>当存储一个文档的时候，它会存储在唯一的主分片中，具体哪个分片是通过散列值进行选择。（所以路由就是计算散列值计算需要路由到哪个分片）。</p><h3 id="路由文档到分片" tabindex="-1"><a class="header-anchor" href="#路由文档到分片" aria-hidden="true">#</a> 路由文档到分片</h3><p>Elasticsearch 在创建文档时，文档会被存储到一个主分片中，决定这个文档应当被存储哪个分片中肯定不是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>shard <span class="token operator">=</span> hash<span class="token punctuation">(</span>routing<span class="token punctuation">)</span> % number_of_primary_shards
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到 余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p><p>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p><p>所有的文档 API （CURD） 都接受一个叫做 routing 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中。</p><h3 id="主分片和副本分片如何交互" tabindex="-1"><a class="header-anchor" href="#主分片和副本分片如何交互" aria-hidden="true">#</a> 主分片和副本分片如何交互</h3><p>假设有一个集群由三个节点组成。 它包含一个叫 blogs 的索引，有两个主分片，每个主分片有两个副本分片。相同分片的副本不会放在同一节点，如下图：</p><p><img src="https://assets.moweilong.com/img/20231027174900.png" alt="ES 主分片和副本分片如何交互"></p><p>我们可以发送请求到集群中的任一节点。 每个节点都有能力处理任意请求。 每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。 在下面的例子中，将所有的请求发送到 Node 1 ，我们将其称为 协调节点(coordinating node) 。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。</p></div><h3 id="索引和删除文档" tabindex="-1"><a class="header-anchor" href="#索引和删除文档" aria-hidden="true">#</a> 索引和删除文档</h3><p>索引和删除请求都是写操作， 必须在主分片上面完成之后才能被复制到相关的副本分片，如下图所示：</p><p><img src="https://assets.moweilong.com/img/20231027174907.png" alt="ES 索引和删除文档"> 以下是在主副分片和任何副本分片上面 成功索引和删除文档所需要的步骤顺序：</p><ol><li>客户端向 Node1 发送新建、索引或者删除请求。</li><li>节点使用文档的 <code>_id</code> 确定文档属于分片 0 。请求会被转发到 Node3，因为分片 0 的主分片目前被分配在 Node3 上。</li><li>Node3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node1 和 Node2 的副本分片上。一旦所有的副本分片都报告成功, Node3 将向协调节点报告成功，协调节点向客户端报告成功。</li></ol><p>在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。</p><h3 id="取回文档" tabindex="-1"><a class="header-anchor" href="#取回文档" aria-hidden="true">#</a> 取回文档</h3><p>可以从主分片或者从其它任意副本分片检索文档 ，如下图所示：</p><p><img src="https://assets.moweilong.com/img/20231027175019.png" alt="ES 取回文档"></p><p>以下是从主分片或者副本分片检索文档的步骤顺序：</p><ol><li>客户端向 Node1 发送获取请求。</li><li>节点使用文档的 <code>_id</code> 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node2 。</li><li>Node2 将文档返回给 Node1 ，然后将文档返回给客户端。</li></ol><p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。</p><p>在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p><h3 id="局部更新文档" tabindex="-1"><a class="header-anchor" href="#局部更新文档" aria-hidden="true">#</a> 局部更新文档</h3><p>update API 结合了先前说明的读取和写入模式，如下图：</p><p><img src="https://assets.moweilong.com/img/20231027175024.png" alt="ES 局部更新文档"></p><p>以下是部分更新一个文档的步骤：</p><ol><li>客户端向 Node1 发送更新请求。</li><li>它将请求转发到主分片所在的 Node3 。</li><li>Node3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。</li><li>如果 Node3 成功地更新文档，它将新版本的文档并行转发到 Node1 和 Node2 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， Node3 向协调节点也返回成功，协调节点向客户端返回成功。</li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>基于文档的复制：当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果 Elasticsearch 仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p></div><h3 id="多文档模式" tabindex="-1"><a class="header-anchor" href="#多文档模式" aria-hidden="true">#</a> 多文档模式</h3><p>ES 提供了两个批量操作的 API：mget 和 bulk API，类似于单文档模式。区别在于协调节点知道每个文档存在于哪个分片中。 它将整个多文档请求分解成<code>每个分片</code>的多文档请求，并且将这些请求并行转发到每个参与节点。</p><p><strong>使用 mget 取回多个文档：</strong></p><p>协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端，如下图所示。</p><p><img src="https://assets.moweilong.com/img/20231027175030.png" alt="ES mget 取回多个文档"></p><p>以下是使用单个 mget 请求取回多个文档所需的步骤顺序：</p><ol><li>客户端向 Node1 发送 mget 请求。</li><li>Node1 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复， Node1 构建响应并将其返回给客户端。</li><li>可以对 docs 数组中每个文档设置 routing 参数。</li></ol><p><strong>使用 bulk 修改多个文档：</strong></p><p>bulk API：允许在单个批量请求中执行多个创建、索引、删除和更新请求，如下图所示：</p><p><img src="https://assets.moweilong.com/img/20231027175057.png" alt="ES bulk 修改多个文档"></p><p>bulk API 按如下步骤顺序执行：</p><ol><li>客户端向 Node1 发送 bulk 请求。</li><li>Node1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。</li><li>主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</li></ol>`,145),o=[t];function i(r,l){return a(),n("div",null,o)}const d=s(p,[["render",i],["__file","ES概念及原理.html.vue"]]);export{d as default};
