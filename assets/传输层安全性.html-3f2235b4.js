import{_ as l,r as t,o,c as i,b as e,d as a,e as n,a as r}from"./app-8ca7f52c.js";const c={},p=r('<h1 id="传输层安全性" tabindex="-1"><a class="header-anchor" href="#传输层安全性" aria-hidden="true">#</a> 传输层安全性</h1><p>Percona Operator for MySQL 使用传输层安全性 （TLS） 加密协议进行以下类型的通信：</p><ul><li>内部 - Percona XtraDB 集群实例之间的通信，</li><li>外部 - 客户端应用程序和 ProxySQL 之间的通信。</li></ul><p>内部证书也用作授权方法。</p><p>可以通过多种方式配置 TLS 安全性。默认情况下，如果没有可用的证书密钥，Operator 会自动生成长期证书。其他选项如下：</p><ul><li>Operator 可以使用专门安装的证书管理器，该管理器将自动生成和续订短期 TLS 证书，</li><li>证书可以手动生成。</li></ul><p>您还可以使用 <code>deploy/ssl-secrets.yaml</code> 文件中提供的预生成证书进行测试，但我们强烈建议避免在任何生产系统上使用它们！</p><p>以下小节说明如何自行使用 Operator 配置 TLS 安全性，以及如何在需要时暂时禁用它。</p><h2 id="安装和使用-cert-manager" tabindex="-1"><a class="header-anchor" href="#安装和使用-cert-manager" aria-hidden="true">#</a> 安装和使用 cert-manager</h2><h3 id="关于-cert-manager" tabindex="-1"><a class="header-anchor" href="#关于-cert-manager" aria-hidden="true">#</a> 关于 cert-manager</h3>',10),d={href:"https://cert-manager.io/docs/",target:"_blank",rel:"noopener noreferrer"},u=r(`<p>如果已安装 cert-manager 并部署了 operator，则 operator 会向 cert-manager 请求证书。cert-manager 充当自签名颁发者并生成证书。Percona Operator 自签名颁发者是 operator 命名空间的本地颁发者。之所以创建此自签名颁发者，是因为 Percona XtraDB Cluster 需要由同一颁发者颁发的所有证书。</p><p>自签名颁发者允许您部署和使用 Percona Operator，而无需单独创建 clusterissuer。</p><h3 id="cert-manager-的安装" tabindex="-1"><a class="header-anchor" href="#cert-manager-的安装" aria-hidden="true">#</a> cert-manager 的安装</h3><p>安装 cert-manager 的步骤如下：</p><ul><li>创建一个 namespace，</li><li>禁用 cert-manager namespace 上的资源验证，</li><li>安装 cert-manager。</li></ul><p>以下命令执行所有必需的操作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl create namespace cert-manager
kubectl label namespace cert-manager certmanager.k8s.io/disable-validation<span class="token operator">=</span>true
kubectl apply <span class="token parameter variable">-f</span> https://github.com/jetstack/cert-manager/releases/download/v1.12.1/cert-manager.yaml
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装完成后，可以通过运行以下命令来验证 cert-manager：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl get pods <span class="token parameter variable">-n</span> cert-manager
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果应显示 cert-manager 和 webhook 处于活动状态且正在运行。</p><h2 id="手动生成证书" tabindex="-1"><a class="header-anchor" href="#手动生成证书" aria-hidden="true">#</a> 手动生成证书</h2><p>若要手动生成证书，请按照下列步骤操作：</p><ol><li>预配证书颁发机构 （CA） 以生成 TLS 证书</li><li>生成包含服务器详细信息的 CA 密钥和证书文件</li><li>使用 CA 密钥、证书和服务器详细信息创建服务器 TLS 证书</li></ol><p>这组命令生成具有以下属性的证书：</p><ul><li><code>Server-pem</code> - Certificate</li><li><code>Server-key.pem</code> - the private key</li><li><code>ca.pem</code> - Certificate Authority</li></ul><p>您应该生成两次证书：一组用于外部通信，另一组用于内部通信。必须将为外部使用而创建的密钥添加到 <code>cr.yaml/spec/secretsName</code> 中。必须将为内部通信生成的证书添加到 <code>cr.yaml/spec/sslInternalSecretName</code> 中。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> cfssl gencert <span class="token parameter variable">-initca</span> - <span class="token operator">|</span> cfssljson <span class="token parameter variable">-bare</span> ca</span>
{
&quot;CN&quot;: &quot;Root CA&quot;,
&quot;key&quot;: {
&quot;algo&quot;: &quot;rsa&quot;,
&quot;size&quot;: 2048
}
}
EOF</span>

<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> cfssl gencert <span class="token parameter variable">-ca</span><span class="token operator">=</span>ca.pem  -ca-key<span class="token operator">=</span>ca-key.pem - <span class="token operator">|</span> cfssljson <span class="token parameter variable">-bare</span> server</span>
{
&quot;hosts&quot;: [
&quot;<span class="token variable">\${CLUSTER_NAME}</span>-proxysql&quot;,
&quot;*.<span class="token variable">\${CLUSTER_NAME}</span>-proxysql-unready&quot;,
&quot;*.<span class="token variable">\${CLUSTER_NAME}</span>-pxc&quot;
],
&quot;CN&quot;: &quot;<span class="token variable">\${CLUSTER_NAME}</span>-pxc&quot;,
&quot;key&quot;: {
&quot;algo&quot;: &quot;rsa&quot;,
&quot;size&quot;: 2048
}
}
EOF</span>

kubectl create secret generic cluster1-ssl --from-file<span class="token operator">=</span>tls.crt<span class="token operator">=</span>server.pem --
from-file<span class="token operator">=</span>tls.key<span class="token operator">=</span>server-key.pem --from-file<span class="token operator">=</span>ca.crt<span class="token operator">=</span>ca.pem --
<span class="token assign-left variable">type</span><span class="token operator">=</span>kubernetes.io/tls
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="更新证书" tabindex="-1"><a class="header-anchor" href="#更新证书" aria-hidden="true">#</a> 更新证书</h2><p>如果使用 cert-manager，它应该负责更新证书。如果手动生成证书，则应注意及时更新证书。</p><p>cert-manager 颁发的 TLS 证书是短期证书。从 Operator 版本 1.9.0 开始，cert-manager 颁发 TLS 证书的有效期为 3 个月，而根证书的有效期为 3 年。这允许按计划自动重新颁发 TLS 证书，而无需停机。</p><p><img src="https://assets.moweilong.com/img/certificates.svg" alt=""></p>`,21),m={href:"https://docs.percona.com/percona-operator-for-mysql/pxc/update.html#operator-update",target:"_blank",rel:"noopener noreferrer"},v=r(`<div class="hint-container tip"><p class="hint-container-title">注意</p><p>如果您使用的 cert-manager 版本低于 1.9.0，并且希望在 Operator 更新到 1.9.0 或更高版本后更新证书时避免停机，请强制 cert-manager 重新生成证书。</p></div><h3 id="检查证书是否过期" tabindex="-1"><a class="header-anchor" href="#检查证书是否过期" aria-hidden="true">#</a> 检查证书是否过期</h3><ol><li>首先，检查必要的机密名称（ <code>cluster1-ssl</code> <code>cluster1-ssl-internal</code> 默认情况下）：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl get certificate
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>您将得到以下响应：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>NAME                    READY   SECRET                  AGE
cluster1-ssl            True    cluster1-ssl            49m
cluster1-ssl-internal   True    cluster1-ssl-internal   49m
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>（可选）您还可以检查证书颁发者是否已启动并正在运行：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl get issuer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>响应应如下所示：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>NAME              READY   AGE
cluster1-pxc-ca   True    49m
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>现在使用以下命令查找证书有效期，并在必要时替换机密名称：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">{</span>
kubectl get secret/cluster1-ssl-internal <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">&#39;{.data.tls\\.crt}&#39;</span> <span class="token operator">|</span> base64 <span class="token parameter variable">--decode</span> <span class="token operator">|</span> openssl x509 <span class="token parameter variable">-inform</span> pem <span class="token parameter variable">-noout</span> <span class="token parameter variable">-text</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">&quot;Not After&quot;</span>
kubectl get secret/cluster1-ssl <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">&#39;{.data.ca\\.crt}&#39;</span> <span class="token operator">|</span> base64 <span class="token parameter variable">--decode</span> <span class="token operator">|</span> openssl x509 <span class="token parameter variable">-inform</span> pem <span class="token parameter variable">-noout</span> <span class="token parameter variable">-text</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">&quot;Not After&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成的输出将是不言自明的：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Not After <span class="token builtin class-name">:</span> Sep <span class="token number">15</span> <span class="token number">11</span>:04:53 <span class="token number">2021</span> GMT
Not After <span class="token builtin class-name">:</span> Sep <span class="token number">15</span> <span class="token number">11</span>:04:53 <span class="token number">2021</span> GMT
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="在不停机的情况下更新证书" tabindex="-1"><a class="header-anchor" href="#在不停机的情况下更新证书" aria-hidden="true">#</a> 在不停机的情况下更新证书</h3><p>如果不使用 cert-manager 并且手动创建了证书，则可以按照以下步骤对这些证书执行无停机更新（如果它们仍然有效）。</p><div class="hint-container tip"><p class="hint-container-title">注意</p><p>对于已过期的证书，请按照替代方法操作。</p></div><p>拥有未过期的证书，您可以按如下方式向操作员推出新证书（CA 和 TLS）。</p><ol><li>生成新的 CA 证书 （ ca.pem ）。（可选）您还可以为其生成新的 TLS 证书和密钥，但这些证书可以在稍后的步骤 6 中生成。</li><li>获取当前 CA （ ca.pem.old ） 和 TLS （ tls.pem.old ） 证书以及 TLS 证书密钥 （ tls.key.old ）：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl get secret/cluster1-ssl-internal <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">&#39;{.data.ca\\.crt}&#39;</span> <span class="token operator">|</span> base64 <span class="token parameter variable">--decode</span> <span class="token operator">&gt;</span> ca.pem.old
kubectl get secret/cluster1-ssl-internal <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">&#39;{.data.tls\\.crt}&#39;</span> <span class="token operator">|</span> base64 <span class="token parameter variable">--decode</span> <span class="token operator">&gt;</span> tls.pem.old
kubectl get secret/cluster1-ssl-internal <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">&#39;{.data.tls\\.key}&#39;</span> <span class="token operator">|</span> base64 <span class="token parameter variable">--decode</span> <span class="token operator">&gt;</span> tls.key.old
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>将新文件和当前 ca.pem 文件合并到一个 ca.pem.combined 文件中：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> ca.pem ca.pem.old <span class="token operator">&gt;&gt;</span> ca.pem.combined
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="4"><li>使用旧的 TLS 证书 （ tls.pem.old ） 和 key （ tls.key.old ） 创建一个新的 Secrets 对象，但使用新的组合 ca.pem （ ca.pem.combined ）：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl delete secret/cluster1-ssl-internal
kubectl create secret generic cluster1-ssl-internal --from-file<span class="token operator">=</span>tls.crt<span class="token operator">=</span>tls.pem.old --from-file<span class="token operator">=</span>tls.key<span class="token operator">=</span>tls.key.old --from-file<span class="token operator">=</span>ca.crt<span class="token operator">=</span>ca.pem.combined <span class="token parameter variable">--type</span><span class="token operator">=</span>kubernetes.io/tls
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li><p>群集将进行滚动协调，但不会出现问题，因为每个节点都有旧的 TLS 证书/密钥，以及新的和旧的 CA 证书。</p></li><li><p>如果在步骤 1 中未生成新的 TLS 证书和密钥，请立即执行此操作。</p></li><li><p>第二次创建新的 Secrets 对象：使用新的 TLS 证书（在示例 server.pem 中）及其密钥 （ server-key.pem ），然后再次使用组合的 CA 证书 （ ca.pem.combined ）：</p></li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl delete secret/cluster1-ssl-internal
kubectl create secret generic cluster1-ssl-internal --from-file<span class="token operator">=</span>tls.crt<span class="token operator">=</span>server.pem --from-file<span class="token operator">=</span>tls.key<span class="token operator">=</span>server-key.pem --from-file<span class="token operator">=</span>ca.crt<span class="token operator">=</span>ca.pem.combined <span class="token parameter variable">--type</span><span class="token operator">=</span>kubernetes.io/tls
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="8"><li><p>群集将进行滚动协调，但不会出现问题，因为每个节点都已具有新的 CA 证书（作为组合 CA 证书的一部分），并且可以成功允许具有新 TLS 证书的加入者加入。Joiner 节点还具有组合的 CA 证书，因此它可以针对较旧的 TLS 证书进行身份验证。</p></li><li><p>创建最终的 Secrets 对象：使用新的 TLS 证书 （ server.pmm ） 及其密钥 （ server-key.pem ），并且仅使用新的 CA 证书 （ ca.pem ）：</p></li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl delete secret/cluster1-ssl-internal
kubectl create secret generic cluster1-ssl-internal --from-file<span class="token operator">=</span>tls.crt<span class="token operator">=</span>server.pem --from-file<span class="token operator">=</span>tls.key<span class="token operator">=</span>server-key.pem --from-file<span class="token operator">=</span>ca.crt<span class="token operator">=</span>ca.pem <span class="token parameter variable">--type</span><span class="token operator">=</span>kubernetes.io/tls
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="10"><li>群集将进行滚动协调，但不会出现任何问题：旧的 CA 证书将被删除，并且每个节点都已使用新的 TLS 证书，并且没有节点再依赖旧的 CA 证书。</li></ol><h3 id="在宕机时更新证书" tabindex="-1"><a class="header-anchor" href="#在宕机时更新证书" aria-hidden="true">#</a> 在宕机时更新证书</h3><p>如果您的证书已过期（或者如果您继续使用 1.9.0 之前的 Operator 版本），则应按如下方式完成<code>暂停 - 更新密钥 - 取消暂停路由</code>。</p>`,31),b={href:"https://docs.percona.com/percona-operator-for-mysql/pxc/pause.html#operator-pause",target:"_blank",rel:"noopener noreferrer"},h=e("li",null,[e("p",null,"如果使用 cert-manager，请删除颁发者和 TLS 证书：")],-1),k=r(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl delete issuer/cluster1-pxc-ca
kubectl delete certificate/cluster1-ssl certificate/cluster1-ssl-internal
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>删除 Secrets 以强制执行 SSL 协调：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl delete secret/cluster1-ssl secret/cluster1-ssl-internal
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,3),g={start:"4"},f=e("li",null,[e("p",null,"检查证书以确保对帐成功。")],-1),_={href:"https://docs.percona.com/percona-operator-for-mysql/pxc/pause.html#operator-pause",target:"_blank",rel:"noopener noreferrer"},S=e("h3",{id:"删除集群后保留证书",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#删除集群后保留证书","aria-hidden":"true"},"#"),a(" 删除集群后保留证书")],-1),x=e("p",null,"删除集群时，默认情况下不会删除为 SSL 创建的对象（Secret、证书和颁发者）。",-1),y=e("code",null,"deploy/cr.yaml",-1),q={href:"https://docs.percona.com/percona-operator-for-mysql/pxc/operator.html#finalizers-delete-ssl",target:"_blank",rel:"noopener noreferrer"},L=e("h2",{id:"在没有-tls-的情况下运行-percona-xtradb-集群",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#在没有-tls-的情况下运行-percona-xtradb-集群","aria-hidden":"true"},"#"),a(" 在没有 TLS 的情况下运行 Percona XtraDB 集群")],-1),T=e("p",null,"省略 TLS 也是可能的，但我们建议您在启用 TLS 协议的情况下运行集群。",-1),A=e("p",null,[a("要禁用 TLS 协议（例如，出于演示目的），请将 "),e("code",null,"cr.yaml/spec/allowUnsafeConfigurations"),a(" 设置编辑为 true 并确保没有可用的证书密钥。")],-1);function C(E,N){const s=t("ExternalLinkIcon");return o(),i("div",null,[p,e("p",null,[e("a",d,[a("cert-manager"),n(s)]),a(" 是一个 Kubernetes 证书管理控制器，广泛用于自动化 TLS 证书的管理和颁发。它是社区驱动的，并且是开源的。")]),u,e("p",null,[a("低于 1.9.0 的 Operator 版本使用了 3 个月的根证书，这会导致自动 TLS 证书更新出现问题。如果是这种情况，您可以根据官方说明"),e("a",m,[a("更新操作员"),n(s)]),a("。")]),v,e("ol",null,[e("li",null,[e("p",null,[a("以"),e("a",b,[a("标准方式"),n(s)]),a("暂停集群，并确保其已达到暂停状态。")])]),h]),k,e("ol",g,[f,e("li",null,[e("p",null,[a("以"),e("a",_,[a("标准方式"),n(s)]),a("取消暂停集群，并确保其已达到运行状态。")])])]),S,x,e("p",null,[a("如果用户想要清理为 SSL 创建的对象，则在 "),y,a(" 中有一个 "),e("a",q,[a("finalizers.delete-ssl"),n(s)]),a(" 选项，如果设置了此终结器，则 Operator 将在集群删除事件后删除 Secret、证书和颁发者。")]),L,T,A])}const M=l(c,[["render",C],["__file","传输层安全性.html.vue"]]);export{M as default};
